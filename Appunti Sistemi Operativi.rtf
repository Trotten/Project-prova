{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 void perror(char* stringa)		stampa sullo stderror l\'92errore che c\'92\'e8 stato, seguito dalla stringa.\
\
int fscanf(FILE* stream, char* format, &parameters)		prende ci\'f2 che trova nello stream e, in base al format, lo mette nei parameters. Ritorna il numero di caratteri letti dallo stream. (forse dovrebbe incrementare il puntatore del file ogni volta che viene letto qualche cosa)\
\
int feof(FILE* stream)	controlla se lo stream \'e8 arrivato all\'92end of file. Restituisce 1 se \'e8 feof, 0 se non \'e8 feof. Nel caso di feof(stdin)==0, risulta sempre uguale a 0 fino a quando non ha letto tutto dallo standard input. Appena ha finito di leggere da l\'ec, lo stdin si mette in attesa, quindi il while non viene eseguito, ma sta ancora alla condizione iniziale per vedere se entrare oppure no. Se viene premuto crtl+d, allora feof(stdin) risulta =1, quindi non viene pi\'f9 eseguito il ciclo.\
\
int fgetc(FILE* stream)		prende il singolo carattere dal file stream; sposta il puntatore stream al carattere successivo. Restituisce il carattere letto, oppure restituisce EOF oppure un errore.\
\
int fputc(int c, FILE* stream)		prende gli interi c(anche caratteri) e li inserisce nel file stream. Restituisce tutti i valori inseriti nel file\
\
char* fgets(char* s, int size, char* stinga)		legge una stringa da stream terminata da \\n o da EOF, di lunghezza massima size. il char* s serve come puntatore che scorre la stringa. \
\
int fputs(const char* s, FILE* stream)		prende la stringa s e la mette in stream, aggiungendo lo \\n (non funziona con la stringa nulla). Restituisce un valore non negativo, oppure un errore se \'e8 EOF.\
\
void rewind(FILE* stream)		setta il puntatore dello stream all\'92inizio.\
\
//differenza da getc o putc: fread e fwrite servono per leggere o scrivere su qualsiasi tipo di elemento, non soltanto stringhe o caratteri come getc e putc. Quindi fread e fwrite possono essere utilizzate anche per leggere o scrivere struttue, ovviamente passandogli la size della struttura.\
\
size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream)		legge dallo stream la stringa(o qualsiasi altro vettore) e la inserisce nella stringa pts. Size \'e8 il numbero di byte di ogni elemento che si sta leggendo; nmemb \'e8 il numero di elementi massimi. Restituisce il numero di elementi letti, che se differisce rispetto al nmbemb, da un errore.\
\
size_t fwrite(const void* ptr, size_t size, size_t nmemb, FILE* stream)		Prende la stringa ptr e la scrive in stream. size \'e8 il numbero di byte di ogni elemento che sta scrivendo, nmemb \'e8 il numero massimo di elementi da scrivere. Ritorna il numero di elementi che ha scritto; se non \'e8 uguale al nmbemb, vuol dire che c\'92\'e8 stato un errore\
\
FUNZIONI DI SISTEMA\
\
int open(const char* pathname, int flags, mode_t mode)		apre il pathname predisponendolo per le operazione di I/O\
\
int creat(const char* pathname, mode_t mode)		\
\
ssize_t read(int fd, void* buf, size_t count)		legge da fd un numbero count di bytes immagazzinandoli nel buffer puntato da buf. buf deve essere di dimensioni adeguate, cio\'e8 almeno di count bytes. La funzione restituisce il numero di elementi letti; viene restituito un numero minore di count se si raggiunge la fine del file, mentre restiutisce -1 in caso di errore.\
\
ssize_t write(int fd, const void* buf, size_t count)		scrive su fd un numbero count bytes di dati presenti nel buffer puntato da buf. La funzione ritorna il numero di elementi scritti, o -1 in caso di errore.\
\
int close(int fd)		chiude il file descriptor fd. Ritorna 0 in caso di successo, -1 in caso di errore.}